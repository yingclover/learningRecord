浏览器是多进程的，每打开一个Tab页，就相当于创建了一个独立的浏览器进程（进程内有自己的多线程）。

### 浏览器包含的进程

1. Browser进程：浏览器的主进程，只有一个，负责浏览器页面的显示，各个页面的管理，如创建销毁其他进程，网络资源的管理下载
2. 第三方插件进程：每种类型的插件对应一个进程
3. GPU进程：最多一个，用于3D绘制
4. 浏览器渲染进程（浏览器内核）：Render进程，内部是多线程的，默认每个Tab页一个进程，互不影响，主要作用是**页面渲染、脚本执行、事件处理**

### 浏览器多进程优势

- 避免单个`page crash`影响整个浏览器
- 避免第三方插件`crash`影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单理解就是：如果浏览器是单进程的，某个`Tab`页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器;
当然，内存等资源消耗也会更大，像空间换时间一样。

### 浏览器内核（渲染进程）

页面的渲染，`js`的执行，事件的循环等都在这个进程内执行;

**浏览器是多进程的，浏览器的渲染进程是多线程的；**

#### GUI渲染线程

- 负责渲染浏览器界面，解析`HTML`,`CSS`,构建`DOM`树和`RenderObject`树，布局和绘制等。
- 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
- 注意，**GUI渲染线程与JS引擎线程是互斥的**，当`JS`引擎执行时`GUI`线程会被挂起（相当于冻结了）,`GUI`更新会被保存在一个队列中等到`JS`引擎空闲时立即被执行。

#### JS引擎线程

- 也称为`JS`内核，负责处理`JavaScript`脚本程序。（例如`V8`引擎）。
- `JS`引擎线程负责解析`JavaScript`脚本，运行代码。
- `JS`引擎一直等待着任务队列中任务的到来，然后加以处理，一个`Tab`页（`render`进程）中无论什么时候都只有一个`JS`线程在运行`JS`程序。
- 同样注意，`GUI`渲染线程与`JS`引擎线程是互斥的，所以如果`JS`执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### 事件触发线程

- 归属于浏览器而不是`JS`引擎，用来控制事件循环（可以理解成`JS`引擎自己都忙不过来，需要浏览器另开线程协助）。
- 当`JS`引擎执行代码块如`setTimeout`时（也可来自浏览器内核的其它线程，如鼠标点击，`AJAX`异步请求等），会将对应任务添加到事件线程中。
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待`JS`引擎的处理。
- 注意，由于`JS`的单线程关系，所以这些待处理队列中的事件都得排队等待`JS`引擎处理（当`JS`引擎空闲时才会去执行）。

#### 定时触发器线程

- 传说中的`setTimeout`和`setInterval`所在的线程
- 浏览器定时计数器并不是由`JavaScript`引擎计数的，（因为`JavaScript`引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待`JS`引擎空闲后执行）
- 注意，`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`。

#### 异步HTTP请求线程

- 在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由`JavaScript`引擎执行

#### 渲染进程

![clipboard.png](https://segmentfault.com/img/bV6ZLo?w=655&h=608)

### Browser主进程和浏览器内核通信过程

打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开`Tab`页的渲染进程）；

- `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过`RendererHost`接口传递给`Render`渲染进程
- `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染
- `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染
- 当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）
- 最后`Render`渲染进程将结果传递给`Browser`主进程
- `Browser`主进程接收到结果并将结果绘制出来

![clipboard.png](https://segmentfault.com/img/bV66KM?w=1034&h=560)

### 浏览器内核中线程之间的关系

**GUI渲染线程与JS引擎线程互斥**

由于`JavaScript`是可操作`DOM`的，如果在修改这些元素属性同时渲染界面（即`JS`线程和`GUI`线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当`JS`引擎执行时`GUI`线程会被挂起。`GUI`更新则会被保存在一个队列中等到`JS`引擎线程空闲时立即被执行。

**JS阻塞页面加载**

从上述的互斥关系，可以推导出，`JS`如果执行时间过长就会阻塞页面。

譬如，假设`JS`引擎正在进行巨量的计算，此时就算`GUI`有更新，也会被保存在队列中，要等到`JS`引擎空闲后执行。然后由于巨量计算，所以`JS`引擎可能很久很久才能空闲，肯定就会感觉很卡。

所以，要尽量避免`JS`执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**css加载是否会阻塞dom树渲染**

这里说的是头部引入`css`的情况
首先，我们都知道：`css`是由单独的下载线程异步下载的。
然后还有几个现象：

1. `css`加载不会阻塞`DOM`树解析（异步加载时`dom`照常构建）
2. 但会阻塞`render`树渲染（渲染时需要等`css`加载完毕，因为`render`树需要`css`信息）

这可能也是浏览器的一种优化机制
因为你加载`css`的时候，可能会修改下面`DOM`节点的样式，如果`css`加载不阻塞`render`树渲染的话，那么当`css`加载完之后，`render`树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗
所以干脆把`DOM`树的结构先解析完，把可以做的工作做完，然后等`css`加载完之后，在根据最终的样式来渲染`render`树，这种做法确实对性能好一点。

**WebWorker,JS的多线程？**

前文中有提到`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？

所以，后来`HTML5`中支持了`WebWorker`。

这样理解下：

创建`Worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`）
`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可，`perfect!`

而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题。

**WebWorker与SharedWorker**

既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）

`WebWorker`只属于某个页面，不会和其他页面的`Render`进程（浏览器内核进程）共享
所以`Chrome`在`Render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。

`SharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`Render`进程，可以为多个`Render`进程共享使用
所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次。

看到这里，应该就很容易明白了，本质上就是进程和线程的区别。`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程

### 浏览器渲染流程

浏览器内核拿到内容后，渲染大概可以划分为：

1. 解析`html`建立`dom`要
2. 解析`css`构建`render`树（将`css`代码解析成树形的数据结构，然后结合`dom`合并成`render`树）
3. 布局`render`树（`Layout/reflow`）,负责各元素尺寸，位置的计算
4. 绘制`render`树（`paint`），绘制页面像素信息
5. 浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成（`composite`）,显示在屏幕上

渲染完毕后就是`load`事件了，之后就是自己的`JS`逻辑处理了，略去了详细步骤。

**load事件与DOMContentLoaded事件的先后**

上面提到，渲染完毕后会触发`load`事件，那么你能分清楚`load`事件与`DOMContentLoaded`事件的先后么？

很简单，知道它们的定义就可以了：

当 `DOMContentLoaded` 事件触发时，仅当`DOM`加载完成，不包括样式表，图片。
(譬如如果有`async`加载的脚本就不一定完成)

当 `onload` 事件触发时，页面上所有的`DOM`，样式表，脚本，图片都已经加载完成了。（渲染完毕了）

所以，顺序是：`DOMContentLoaded` -> `load`

### 普通图层和复合图层

浏览器渲染的图层一般包含两大类：普通图层以及复合图层。

1. 普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）
2. `absolute`布局（`fixed`也一样），虽然可以脱离文档流，但它仍然属于默认复合层
3. 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

可以简单理解下：**`GPU`中，各个复合图层是单独绘制的，所以互不影响**，这也是为什么某些场景硬件加速效果一级棒

**如何变成复合图层（硬件加速）**

将元素变成一个复合图层，就是传说中的硬件加速技术

- 最常用的方式：`translate3d`,`translatez`
- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
- `<video><iframe><canvas><webgl>`等元素
- 其它，譬如以前的`flash`插件

**absolute和硬件加速的区别**

可以看到，`absolute`虽然可以脱离普通文档流，但是无法脱离默认复合层。

所以，就算`absolute`中信息改变时不会改变普通文档流中`render`树，但是，浏览器最终绘制时，是整个复合层绘制的，所以`absolute`中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，`absolute`带来的绘制信息变化过大，资源消耗是非常严重的）

而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）

**复合图层的作用**

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。
但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。

**硬件加速时请使用index**

使用硬件加速时，尽可能的使用index,防止浏览器默认给后续的元素创建复合层渲染
具体的原理是：
`webkit CSS3`中，如果这个元素添加了硬件加速，并且`index`层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且`relective`或`absolute`属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能

简单点理解，可以认为是一个隐式合成的概念：如果a是一个复合层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意

### 从`Event Loop`谈`JS`的运行机制

- `JS`分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕（此时`JS`引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。

定时器线程：调用`setTimeout`后，是由定时器线程控制等到特定时间后添加到事件队列的，因为`JS`引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。当使用`setTimout`或`setInterval`时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。

setInterval累积导致计时不准确时可以用setTImeout模拟或者特殊场合用requestAnimationFrame代替。

