https://blog.csdn.net/wolf_love666/article/details/93600904

### http与https

https://blog.csdn.net/xiaoming100001/article/details/81109617

##### 基本概念

HTTP：超文本传输协议，客户端和服务器端请求和应答的标准（TCP），主要是规定了客户端和服务器之间的通信格式,用于从WWW服务器传输超文本到本地浏览器的传输协议。

HTTPS：HTTP的安全版，即HTTP下加入SSL层，HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTP + 加密 + 认证 + 完整性保护

1）认证用户和服务器，确保数据发送到正确的客户机和服务器；

2）加密数据以防止数据中途被窃取；

3）维护数据的完整性，确保数据在传输过程中不被改变。





##### 工作原理

HTTP：

1、Client与Server建立连接，单击某个超链接，HTTP的工作开始。

2、连接建立后，Client发送一个请求给Server，请求方式的格式为：统一资源标识符（URL）、协议版本号、状态码，后边是MIME信息包括请求修饰符，Client信息和可能的内容。

3、Server接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括Server信息、实体信息和可能的内容。

4、Client接收Server返回的信息通过浏览器显示在用户的显示屏上，然后Client和Server断开连接。

1.0和1.1区别：

1、HTTP/1.0是短连接，每对请求/ 响应都使用一个新的连接；而HTTP/1.1则是默认持久连接；（HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。）
2、请求方法：HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT这些Request方法；

3、状态码：HTTP/1.0中只定义了16个状态响应码，对错误或警告的提示不够具体。HTTP/1.1引入了一个Warning头域，增加对错误或警告信息的描述；在HTTP/1.1中新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

4、Host域： HTTP1.1在Request消息头里头多了一个Host域

HTTPS:

1、client向server发送请求https://baidu.com，然后连接到server的443端口。

2、服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。

3、传送证书 
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

4、客户端解析证书 
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（秘钥）。然后用证书对该随机值进行加密。

5、传送加密信息 
这部分传送的是用证书加密后的秘钥，目的就是让服务端得到这个秘钥，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6、服务段加密信息 
服务端用私钥解密秘密秘钥，得到了客户端传过来的私钥，然后把内容通过该值进行对称加密。

7、传输加密后的信息 
这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。

8、客户端解密信息 

客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容

##### 区别

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

##### HTTPS优缺点

优点：

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

缺点：

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

3、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

##### HTTP切换到HTTPS

如果需要将网站从http切换到https到底该如何实现呢？

这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：[http://www.baidu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com)改为[https://www.baidu.com](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.baidu.com)

这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将[http://www.baidu.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.baidu.com)改为[//www.baidu.com](https://links.jianshu.com/go?to=%2F%2Fwww.baidu.com)。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。

##### HTTP2.0

http2.0是基于1999年发布的http1.0之后的首次更新。

提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）

允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码

首部压缩

服务器端推送

##### 状态码

> 1XX：消息提示 
>
> 2XX：成功 
>
> 3XX：重定向 
>
> 4XX：请求错误 
>
> 5XX：服务器错误

200：请求被正常处理
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
301：永久性重定向
302：临时重定向

**301和302区别**：

302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。

303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
400 Bad Request：请求报文语法有误，服务器无法识别
401 Unauthorized：请求需要认证
403 Forbidden：请求的对应资源禁止被访问
404 Not Found：服务器无法找到对应资源
500 Internal Server Error：服务器内部错误

503 Service Unavialable：服务器正忙

##### 关于301和302

详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。

301比较常用的场景是使用**域名跳转**。

　　比如，我们访问 http://ww.baidu.com 会跳转到 https://ww.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 

注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。

　   **网页扩展名修改**：把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。

尽量使用301，因为302可能会发生网址劫持：即网址A 做一个302 重定向到你的网址B，出于某种原因，搜索引擎搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持

### TCP三次握手四次挥手

![1562932328629](C:\Users\Ying\AppData\Roaming\Typora\typora-user-images\1562932328629.png)

为什么握3次？

初始化序列号的初始值，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。

建立连接时，client故障怎么办？

保活机制，像客户端发送保活探测报文，如果没有收到响应就继续发送，直到达到一定次数任未响应就中断连接。

SYN攻击？

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。

![1562932307336](C:\Users\Ying\AppData\Roaming\Typora\typora-user-images\1562932307336.png)

为什么需要等待2MSL？

1、如果客户端第四次挥手的确认报文段没有被服务器接收，那么服务器端会重发第三次挥手的Fin包，所以客户端需要2MSL的时间来处理可能重复收到的报文段。

2、避免新旧连接混淆，造成混乱。

为什么需要四次挥手呢？

TCP是全双工模式，发送方和接收方都需要发送Fin和Ack包，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。

### GET和POST

https://www.jianshu.com/p/fcdc0f86633a

https://www.jianshu.com/p/22aad0481886

1、get在浏览器回退时是无害的，而post会再次请求

2、get产生的url地址可以被收藏，而post不会

3、get请求会被浏览器主动缓存，而post不会，除非手动设置

4、get请求只能进行url编码，而post支持多种编码方式

5、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留

6、get 请求在url中传送的参数有长度限制，而post没有

7、对参数的数据类型，get只接受ascll字符，而post没有限制

8、get比post更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息

9、get参数通过url传递，post放在request body中
 （记不住全部的，重点回答出1，2，5，6，9这几点即可）

GET产生一个TCP数据包;POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)

**语义上讲**GET是用来向获取服务器信息的，请求报文传输的信息只是用于描述所需资源的参数，返回的信息才是数据本身；POST是用来向服务器传递数据的，其请求报文传递的信息就是数据本身，返回的报文只是操作的结果。这是GET和POST最重要的区别，没有之一。

幂等的含义是多次请求，效果一致，GET符合幂等性和安全性，**安全(Safe)方法包括GET都是幂等的,POST不是幂等的。**

### 浏览器渲染过程

用户输入URL地址
浏览器解析URL解析出主机名
浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）
浏览器将端口号从URL中解析出来
浏览器建立一条与目标Web服务器的TCP连接（三次握手）
浏览器向服务器发送一条HTTP请求报文
服务器向浏览器返回一条HTTP响应报文
关闭连接 浏览器解析文档，渲染页面
如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕

#### 客户端渲染

- 解析HTML构建DOM树
- 解析CSS构建CSSDOM树
- 将DOM和CSSDOM合并成一个渲染树
- 根据渲染树进行布局，计算每个节点的几何信息
- 将各个节点绘制到屏幕上

#### 重绘和重排

**重排**：当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。引发重排的因素有：

- 添加或删除可见的DOM元素
- 元素位置改变
- 元素本身的尺寸发生改变
- 内容改变
- 页面渲染器初始化
- 浏览器窗口大小发生改变

**重绘**：完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。

#### 关于性能优化

重排和重绘会影响浏览器性能，所以需要减少重排和重绘。

1. 改变样式,通过classText或者class集中改变

   ![1564737710809](C:\Users\Ying\AppData\Roaming\Typora\typora-user-images\1564737710809.png)

2. 批量修改DOM

   如果我们需要对DOM元素进行多次修改，怎么去减少重排和重绘的次数呢？利用上面修改样式的方法不就行了吗。回过头看一下造成页面重排的几个要点里，可以明确的看到，造成元素几何属性发生改变就会触发重排，现在需要增加10个节点，必然涉及到DOM的修改，这个时候就需要利用批量修改DOM这种优化方式了，这里也能看到，改变样式最小化重绘和重排这种优化方式适用于单个存在的节点。
   批量修改DOM元素的核心思想是：

   - 让该元素脱离文档流
   - 对其进行多重改变
   - 将元素带回文档中

   可以这样实现：

   - 隐藏元素，进行修改后，然后再显示该元素

     ```javascript
     dom.display = 'none'
     // 修改dom样式
     dom.display = 'block'
     ```

   - 使用文档片段创建一个子树，然后再拷贝到文档中

   - 将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素

   比如下面的例子：

   ```html
   // html
   <ul id="mylist">
     <li><a href="https://www.mi.com">xiaomi</a></li>
     <li><a href="https://www.miui.com">miui</a></li>
   </ul>
   
   // javascript 现在需要添加带有如下信息的li节点
   let data = [
     {
       name: 'tom',
       url: 'https://www.baidu.com',
     },
     {
         name: 'ann',
         url: 'https://www.techFE.com'
     }
   ]
   ```

   ```javascript
   // javascript一个通用的用于将新数据更新到指定节点的方法
   function appendNode($node, data) {
     var a, li;
     
     for(let i = 0, max = data.length; i < max; i++) {
       a = document.createElement('a');
       li = document.createElement('li');
       a.href = data[i].url;
       
       a.appendChild(document.createTextNode(data[i].name));
       li.appendChild(a);
       $node.appendChild(li);
     }
   }
   ```

   首先我们忽视所有的重排因素，大家肯定会这么写：

   ```javascript
   let ul = document.querySelector('#mylist');
   appendNode(ul, data);
   ```

   使用这种方法，在没有任何优化的情况下，每次插入新的节点都会造成一次重排（这几部分我们都先讨论重排，因为重排是性能优化的第一步）。考虑这个场景，如果我们添加的节点数量众多，而且布局复杂，样式复杂，那么能想到的是你的页面一定非常卡顿。我们利用批量修改DOM的优化手段来进行重构.

   **1）隐藏元素，进行修改后，然后再显示该元素**

   ```javascript
   let ul = document.querySelector('#mylist');
   ul.style.display = 'none';
   appendNode(ul, data);
   ul.style.display = 'block';
   ```

   这种方法造成俩次重排，分别是控制元素的显示与隐藏。对于复杂的，数量巨大的节点段落可以考虑这种方法。为啥使用display属性呢，因为display为none的时候，元素就不在文档流了，还不熟悉的老铁，手动Google一下，display:none, opacity: 0, visibility: hidden的区别

   **2）使用文档片段创建一个子树，然后再拷贝到文档中**

   ```javascript
   let fragment = document.createDocumentFragment();
   appendNode(fragment, data);
   ul.appendChild(fragment);
   ```

   我是比较喜欢这种方法的，文档片段是一个轻量级的document对象，它设计的目的就是用于更新，移动节点之类的任务，而且文档片段还有一个好处就是，当向一个节点添加文档片段时，添加的是文档片段的子节点群，自身不会被添加进去。不同于第一种方法，这个方法并不会使元素短暂消失造成逻辑问题。上面这个例子，只在添加文档片段的时候涉及到了一次重排。

   **3）将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素**

   ```javascript
   let old = document.querySelector('#mylist');
   let clone = old.cloneNode(true);
   appendNode(clone, data);
   old.parentNode.replaceChild(clone, old);
   ```

   可以看到这种方法也是只有一次重排。总的来说，使用文档片段，可以操作更少的DOM（对比使用克隆节点），最小化重排重绘次数。

3. 缓存布局信息

   比如我现在要得到页面ul节点下面的100个li节点，最好的办法就是第一次获取后就保存起来，减少DOM的访问以提升性能，缓存布局信息也是同样的概念。**当访问诸如offsetLeft，clientTop这种属性时，会冲破浏览器自有的优化————通过队列化修改和批量运行的方法，减少重排/重绘版次。所以我们应该尽量减少对布局信息的查询次数，查询时，将其赋值给局部变量，使用局部变量参与计算**。

   将元素div向右下方平移，每次移动1px，起始位置100px, 100px。性能糟糕的代码：

   ```javascript
   div.style.left = 1 + div.offsetLeft + 'px';
   div.style.top = 1 + div.offsetTop + 'px';
   ```

   这样造成的问题就是，每次都会访问div的offsetLeft，造成浏览器强制刷新渲染队列以获取最新的offsetLeft值。更好的办法就是，将这个值保存下来，避免重复取值

   ```javascript
   current = div.offsetLeft;
   div.style.left = 1 + ++current + 'px';
   div.style.top = 1 + ++current + 'px';
   ```

### cookie和session

**原理**

cookie执行流程

当你去访问应用的时候,来到服务器。服务器设置一个cookie（后边介绍api），在做响应的时候会通过set-cookie响应头将cookie带给浏览器。

来到浏览器,浏览器会将此数据保存起来,接下来再次去访问服务器的时候,浏览器会根据cookie的path属性（后边api介绍）将这些数据带回去(设置了一个叫做cookie的请求头),来到服务器,服务器有对应的api获取这些值，有了值就知道用户是谁了。

session执行流程

浏览器发起一个请求到服务器,服务器先检查你是否携带了一个叫做JSESSIONID的cookie。

如果有携带，会将此cookie的值取出来（比如为aaa123），然后从服务器的session池中找到ID为aaa123的session返回给调用者。

如果没有携带这个JSESSIONID的cookie，那么服务器将会自动创建一个session对象并且生成一个随机字符串（如aaa123）作为此session的ID保存到session池中。在服务器为客户端浏览器作响应的时候自动创建一个键为“JSESSIONID” 值为“aaa123”的cookie对象让浏览器储存起来以便下次再访问的时候带过来。

**区别**

1、Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。
2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。cookie只能存放4k的数据，而session理论上没有做限制
3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。
4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

**session产生的session_id放在cookie里面，如果用户把cookie禁止掉，是不是session也不能用了呢？**

禁止掉cookie后，session当然可以用，不过通过其他的方式来获得这个sessionid，比如，可以跟在url的后面，或者以表单的形式提交到服务器端。从而使服务器端了解客户端的状态。
**使session失效的方法：**

1.关闭tomcat  2.重启web应用  3.session时间到  4.无效的session

session和cookie的区别

①存在的位置：

cookie 存在于客户端，临时文件夹中；  session存在于服务器的内存中，一个session域对象为一个用户浏览器服务

②安全性
cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；  session存放于服务器的内存中，所以安全性好

③网络传输量
cookie会传递消息给服务器；  session本身存放于服务器，不会有传送流量

④生命周期(以20分钟为例)
cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束；
session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁。但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期。关机会造成session生命周期的结束，但是对cookie没有影响

⑤访问范围

cookie为多个用户浏览器共享；  session为一个用户浏览器独享

### web性能优化

#### 浏览器内核

#### 浏览器存储技术

cookie用来保存客户浏览器请求服务器页面的请求信息

HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）

WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器，三者的共同点都是保存在浏览器端，且同源

下面是他们之间的区别

**生命周期**

cookie：可以通过expires设置失效时间，不设置默认关闭浏览器即失效

localStorage：除非手动清除，否则永久保存

sessionStorage：仅在当前会话时候生效，关闭页面即失效

**存储大小**

cookie:4KB左右

localStorage、sessionStorage:可以保存5M的信息

**HTTP请求**

cookie:每次都会携带在http头中，过多使用cookie会带来性能问题

localStorage、sessionStorage:仅在客户端（即浏览器）中保存，不参与和服务器的通信

**易用性**

cookie:需要程序员自己封装，源生的Cookie接口不友好

localStorage、sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

**应用场景**

cookie：适合识别用户登录

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息

localStorage：可以用来跨页面传递参数

sessionStorage：用来保存临时数据，防止用户刷新页面之后丢失参数